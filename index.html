<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NodeFlow</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1e1e21;
    overflow: hidden;
    font-family: 'DM Sans', sans-serif;
    color: #c4c4c8;
    user-select: none;
    height: 100vh;
    width: 100vw;
  }

  canvas#bgCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  #mainCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    cursor: grab;
  }

  #mainCanvas.grabbing { cursor: grabbing; }

  /* UI Overlay */
  .title-bar {
    position: fixed;
    top: 16px;
    left: 20px;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 10px;
    pointer-events: none;
  }

  .title-bar .logo {
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 500;
    color: #7c6fef;
    letter-spacing: -0.5px;
  }

  .title-bar .hint {
    font-size: 11px;
    color: #444;
  }

  .status-bar {
    position: fixed;
    top: 16px;
    right: 20px;
    z-index: 100;
    text-align: right;
    pointer-events: none;
  }

  .zoom-text {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: #444;
  }

  .sync-text {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: #666;
    margin-top: 2px;
    transition: color 0.3s;
  }

  .toolbar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 4px;
    background: #242529;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 6px 10px;
    z-index: 100;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  }

  .toolbar button {
    background: transparent;
    border: 1px solid transparent;
    color: #888;
    padding: 6px 11px;
    border-radius: 8px;
    font-family: 'DM Sans', sans-serif;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .toolbar button:hover {
    background: #2f3035;
    color: #ddd;
    border-color: #444;
  }

  .toolbar .sep {
    width: 1px;
    height: 20px;
    background: #333;
    margin: 0 2px;
    align-self: center;
  }

  /* Node tooltip / edit */
  .node-edit-overlay {
    position: fixed;
    z-index: 200;
    display: none;
  }

  .node-edit-overlay.show {
    display: block;
  }

  .node-edit-input {
    background: #2a2b30;
    border: 1.5px solid #7c6fef;
    border-radius: 8px;
    padding: 6px 12px;
    color: #eee;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    font-weight: 500;
    outline: none;
    min-width: 160px;
    caret-color: #7c6fef;
    box-shadow: 0 4px 20px rgba(124, 111, 239, 0.15);
  }

  /* Context menu */
  .context-menu {
    position: fixed;
    background: #242529;
    border: 1px solid #3a3b40;
    border-radius: 10px;
    padding: 4px;
    z-index: 200;
    min-width: 150px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    display: none;
  }

  .context-menu.show { display: block; }

  .context-menu button {
    display: block;
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    color: #c4c4c8;
    font-family: 'DM Sans', sans-serif;
    font-size: 12px;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.1s;
  }

  .context-menu button:hover {
    background: #2f3035;
    color: #eee;
  }

  .context-menu button.danger { color: #e55; }
  .context-menu button.danger:hover { background: rgba(238,85,85,0.1); }

  .color-dots {
    display: flex;
    gap: 5px;
    padding: 6px 10px;
  }

  .color-dot {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
  }

  .color-dot:hover { transform: scale(1.25); border-color: #fff3; }

  /* Toast */
  .toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-60px);
    background: #242529;
    border: 1px solid #3a3b40;
    padding: 8px 18px;
    border-radius: 10px;
    font-size: 12px;
    color: #aaa;
    z-index: 300;
    transition: transform 0.3s ease;
    pointer-events: none;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  }

  .toast.show { transform: translateX(-50%) translateY(0); }

  input[type="file"] { display: none; }
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>
<canvas id="mainCanvas"></canvas>

<div class="title-bar">
  <span class="logo">NodeFlow</span>
  <span class="hint">click node to select · drag to fling · double-click canvas to add · Tab to branch</span>
</div>

<div class="status-bar">
  <div class="zoom-text" id="zoomText">100%</div>
  <div class="sync-text" id="syncStatus">connecting...</div>
</div>

<div class="toolbar">
  <button onclick="addNodeAtCenter()">+ New Node</button>
  <div class="sep"></div>
  <button onclick="fitView()">⊡ Fit</button>
  <button onclick="togglePhysics()">⟳ Physics: <span id="physToggle">ON</span></button>
  <div class="sep"></div>
  <button onclick="exportJSON()">↓ Save</button>
  <button onclick="document.getElementById('fileInput').click()">↑ Load</button>
  <div class="sep"></div>
  <button onclick="clearAll()">✕ Clear</button>
</div>

<div class="node-edit-overlay" id="editOverlay">
  <input class="node-edit-input" id="editInput" type="text" spellcheck="false">
</div>

<div class="context-menu" id="contextMenu">
  <button onclick="ctxAction('rename')">✎ Rename</button>
  <button onclick="ctxAction('addChild')">+ Add Child</button>
  <div class="color-dots" id="colorDots"></div>
  <button class="danger" onclick="ctxAction('delete')">✕ Delete</button>
</div>

<div class="toast" id="toast"></div>
<input type="file" id="fileInput" accept=".json" onchange="handleFileLoad(event)">

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
// ══════════════════════════════════════════
// ── CONFIG ──
const SUPABASE_URL = 'https://qsphmbquuruguemgdiym.supabase.co';
const SUPABASE_KEY = 'sb_publishable_-uS8PtHTOvoVc5-MZrkvrA_Wbt5ljBz';
const MAP_ID = 'default';
// ══════════════════════════════════════════

// ── State ──
let nodes = [];
let edges = [];
let nextId = 1;
let pan = { x: 0, y: 0 };
let zoom = 1;
let physicsEnabled = true;
let selectedNode = null;
let hoveredNode = null;
let draggingNode = null;
let panning = false;
let panStart = { x: 0, y: 0 };
let dragOffset = { x: 0, y: 0 };
let contextNodeId = null;
let editingNode = null;
let animFrame = null;
let dirty = false;

const NODE_COLORS = ['#7c6fef', '#ef6f8a', '#6fefb2', '#efcf6f', '#6fb8ef', '#ef8f6f', '#b86fef', '#6fefd4'];
const NODE_RADIUS_BASE = 8;
const NODE_RADIUS_ROOT = 12;
const LABEL_FONT = '500 12px DM Sans';
const ROOT_LABEL_FONT = '600 14px DM Sans';
const LINK_DISTANCE = 180;
const REPULSION = 3000;
const ATTRACTION = 0.005;
const DAMPING = 0.85;
const CENTER_PULL = 0.0003;

// ── Canvas setup ──
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');
const mainCanvas = document.getElementById('mainCanvas');
const ctx = mainCanvas.getContext('2d');

function resize() {
  const dpr = window.devicePixelRatio || 1;
  bgCanvas.width = window.innerWidth * dpr;
  bgCanvas.height = window.innerHeight * dpr;
  bgCanvas.style.width = window.innerWidth + 'px';
  bgCanvas.style.height = window.innerHeight + 'px';
  bgCtx.scale(dpr, dpr);

  mainCanvas.width = window.innerWidth * dpr;
  mainCanvas.height = window.innerHeight * dpr;
  mainCanvas.style.width = window.innerWidth + 'px';
  mainCanvas.style.height = window.innerHeight + 'px';
  ctx.scale(dpr, dpr);

  drawBackground();
}

window.addEventListener('resize', resize);

function drawBackground() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  bgCtx.fillStyle = '#1e1e21';
  bgCtx.fillRect(0, 0, w, h);

  // Subtle dot grid
  const gridSize = 30;
  const offsetX = pan.x % (gridSize * zoom);
  const offsetY = pan.y % (gridSize * zoom);

  bgCtx.fillStyle = '#2a2a2e';
  for (let x = offsetX; x < w; x += gridSize * zoom) {
    for (let y = offsetY; y < h; y += gridSize * zoom) {
      bgCtx.beginPath();
      bgCtx.arc(x, y, 0.8, 0, Math.PI * 2);
      bgCtx.fill();
    }
  }
}

// ── Node helpers ──
function createNode(label, wx, wy, parentId, isRoot) {
  const id = nextId++;
  const parentColor = parentId ? (nodes.find(n => n.id === parentId)?.color || '#7c6fef') : '#7c6fef';
  const node = {
    id, label,
    x: wx, y: wy,
    vx: 0, vy: 0,
    isRoot: !!isRoot,
    color: isRoot ? '#7c6fef' : parentColor,
    pinned: false
  };
  nodes.push(node);
  if (parentId != null) {
    edges.push({ from: parentId, to: id });
  }
  dirty = true;
  return id;
}

function deleteNode(id) {
  const node = nodes.find(n => n.id === id);
  if (!node || node.isRoot) return;
  const toDelete = new Set();
  const queue = [id];
  while (queue.length) {
    const curr = queue.shift();
    toDelete.add(curr);
    edges.filter(e => e.from === curr).forEach(e => queue.push(e.to));
  }
  nodes = nodes.filter(n => !toDelete.has(n.id));
  edges = edges.filter(e => !toDelete.has(e.from) && !toDelete.has(e.to));
  if (selectedNode === id) selectedNode = null;
  dirty = true;
}

function addChild(parentId) {
  const parent = nodes.find(n => n.id === parentId);
  if (!parent) return;

  const angle = Math.random() * Math.PI * 2;
  const dist = LINK_DISTANCE * 0.7;
  const nx = parent.x + Math.cos(angle) * dist;
  const ny = parent.y + Math.sin(angle) * dist;

  const id = createNode('New node', nx, ny, parentId);
  selectedNode = id;
  startEdit(id);
  return id;
}

function addNodeAtCenter() {
  const wx = (window.innerWidth / 2 - pan.x) / zoom;
  const wy = (window.innerHeight / 2 - pan.y) / zoom;
  const id = createNode('New node', wx + (Math.random() - 0.5) * 60, wy + (Math.random() - 0.5) * 60, null, false);
  selectedNode = id;
  startEdit(id);
}

// ── Physics ──
function simulate() {
  if (!physicsEnabled) return;

  const n = nodes.length;

  // Repulsion between all pairs
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const a = nodes[i], b = nodes[j];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let force = REPULSION / (dist * dist);
      let fx = (dx / dist) * force;
      let fy = (dy / dist) * force;
      if (!a.pinned) { a.vx -= fx; a.vy -= fy; }
      if (!b.pinned) { b.vx += fx; b.vy += fy; }
    }
  }

  // Attraction along edges
  edges.forEach(e => {
    const a = nodes.find(n => n.id === e.from);
    const b = nodes.find(n => n.id === e.to);
    if (!a || !b) return;
    let dx = b.x - a.x;
    let dy = b.y - a.y;
    let dist = Math.sqrt(dx * dx + dy * dy) || 1;
    let force = (dist - LINK_DISTANCE) * ATTRACTION;
    let fx = (dx / dist) * force;
    let fy = (dy / dist) * force;
    if (!a.pinned) { a.vx += fx; a.vy += fy; }
    if (!b.pinned) { b.vx -= fx; b.vy -= fy; }
  });

  // Gentle center pull
  const cx = nodes.reduce((s, n) => s + n.x, 0) / (n || 1);
  const cy = nodes.reduce((s, n) => s + n.y, 0) / (n || 1);

  nodes.forEach(node => {
    if (node.pinned) return;
    node.vx -= (node.x - cx) * CENTER_PULL;
    node.vy -= (node.y - cy) * CENTER_PULL;
    node.vx *= DAMPING;
    node.vy *= DAMPING;
    node.x += node.vx;
    node.y += node.vy;
  });
}

// ── Rendering ──
function worldToScreen(wx, wy) {
  return { x: wx * zoom + pan.x, y: wy * zoom + pan.y };
}

function screenToWorld(sx, sy) {
  return { x: (sx - pan.x) / zoom, y: (sy - pan.y) / zoom };
}

function getNodeRadius(node) {
  return (node.isRoot ? NODE_RADIUS_ROOT : NODE_RADIUS_BASE) * zoom;
}

function render() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  ctx.clearRect(0, 0, w, h);

  drawBackground();

  // Draw edges
  edges.forEach(e => {
    const from = nodes.find(n => n.id === e.from);
    const to = nodes.find(n => n.id === e.to);
    if (!from || !to) return;
    const p1 = worldToScreen(from.x, from.y);
    const p2 = worldToScreen(to.x, to.y);

    const isHighlight = selectedNode && (e.from === selectedNode || e.to === selectedNode);

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);

    if (isHighlight) {
      ctx.strokeStyle = 'rgba(124, 111, 239, 0.6)';
      ctx.lineWidth = 2 * zoom;
    } else {
      ctx.strokeStyle = 'rgba(58, 59, 64, 0.6)';
      ctx.lineWidth = 1.2 * zoom;
    }
    ctx.stroke();
  });

  // Draw nodes
  nodes.forEach(node => {
    const p = worldToScreen(node.x, node.y);
    const r = getNodeRadius(node);
    const isSelected = selectedNode === node.id;
    const isHovered = hoveredNode === node.id;
    const isConnected = selectedNode && edges.some(e =>
      (e.from === selectedNode && e.to === node.id) ||
      (e.to === selectedNode && e.from === node.id)
    );

    // Glow
    if (isSelected || isHovered) {
      const grad = ctx.createRadialGradient(p.x, p.y, r, p.x, p.y, r * 4);
      grad.addColorStop(0, (node.color || '#7c6fef') + '40');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r * 4, 0, Math.PI * 2);
      ctx.fill();
    }

    // Outer ring
    ctx.beginPath();
    ctx.arc(p.x, p.y, r + 2 * zoom, 0, Math.PI * 2);
    ctx.fillStyle = (isSelected || isHovered) ? (node.color || '#7c6fef') + '60' : 'transparent';
    ctx.fill();

    // Node circle
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);

    let dimmed = selectedNode && !isSelected && !isConnected && selectedNode !== node.id;

    if (isSelected || isHovered) {
      ctx.fillStyle = node.color || '#7c6fef';
    } else if (dimmed) {
      ctx.fillStyle = (node.color || '#7c6fef') + '40';
    } else {
      ctx.fillStyle = (node.color || '#7c6fef') + 'bb';
    }
    ctx.fill();

    // Border
    ctx.strokeStyle = isSelected ? '#fff3' : 'transparent';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Label
    if (editingNode === node.id) return;

    const fontSize = (node.isRoot ? 14 : 12) * zoom;
    ctx.font = `${node.isRoot ? 600 : 500} ${fontSize}px DM Sans`;

    if (dimmed) {
      ctx.fillStyle = '#ffffff30';
    } else {
      ctx.fillStyle = isSelected ? '#fff' : '#d1d1d6';
    }

    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(node.label, p.x, p.y + r + 6 * zoom);

    // + button indicator on hover
    if (isHovered && !draggingNode) {
      const bx = p.x + r + 8 * zoom;
      const by = p.y - r - 4 * zoom;
      const br = 8 * zoom;
      ctx.beginPath();
      ctx.arc(bx, by, br, 0, Math.PI * 2);
      ctx.fillStyle = '#2a2b30';
      ctx.fill();
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = '#7c6fef';
      ctx.font = `${600} ${12 * zoom}px DM Sans`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('+', bx, by);
    }
  });

  document.getElementById('zoomText').textContent = Math.round(zoom * 100) + '%';
}

function loop() {
  simulate();
  render();
  animFrame = requestAnimationFrame(loop);
}

// ── Hit testing ──
function hitTest(sx, sy) {
  const w = screenToWorld(sx, sy);
  let closest = null;
  let closestDist = Infinity;
  nodes.forEach(node => {
    const dx = w.x - node.x;
    const dy = w.y - node.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const hitRadius = (node.isRoot ? NODE_RADIUS_ROOT : NODE_RADIUS_BASE) * 2.5 / zoom + 15;
    if (dist < hitRadius && dist < closestDist) {
      closest = node;
      closestDist = dist;
    }
  });
  return closest;
}

function hitTestAddButton(sx, sy) {
  if (!hoveredNode) return false;
  const node = nodes.find(n => n.id === hoveredNode);
  if (!node) return false;
  const p = worldToScreen(node.x, node.y);
  const r = getNodeRadius(node);
  const bx = p.x + r + 8 * zoom;
  const by = p.y - r - 4 * zoom;
  const br = 10 * zoom;
  const dx = sx - bx;
  const dy = sy - by;
  return Math.sqrt(dx * dx + dy * dy) < br;
}

// ── Input handling ──
mainCanvas.addEventListener('mousedown', (e) => {
  hideContext();
  const node = hitTest(e.clientX, e.clientY);

  if (e.button === 2) return;

  if (hitTestAddButton(e.clientX, e.clientY)) {
    addChild(hoveredNode);
    return;
  }

  if (node) {
    selectedNode = node.id;
    draggingNode = node.id;
    node.pinned = true;
    const p = worldToScreen(node.x, node.y);
    dragOffset = { x: e.clientX - p.x, y: e.clientY - p.y };
    mainCanvas.classList.add('grabbing');
  } else {
    selectedNode = null;
    panning = true;
    panStart = { x: e.clientX - pan.x, y: e.clientY - pan.y };
    mainCanvas.classList.add('grabbing');
  }
});

mainCanvas.addEventListener('mousemove', (e) => {
  if (draggingNode) {
    const node = nodes.find(n => n.id === draggingNode);
    if (node) {
      const wx = (e.clientX - dragOffset.x - pan.x) / zoom;
      const wy = (e.clientY - dragOffset.y - pan.y) / zoom;
      // Give it velocity based on movement for fling
      node.vx = (wx - node.x) * 0.3;
      node.vy = (wy - node.y) * 0.3;
      node.x = wx;
      node.y = wy;
      dirty = true;
    }
  } else if (panning) {
    pan.x = e.clientX - panStart.x;
    pan.y = e.clientY - panStart.y;
  } else {
    const node = hitTest(e.clientX, e.clientY);
    hoveredNode = node ? node.id : null;
    mainCanvas.style.cursor = node ? 'pointer' : 'grab';
  }
});

mainCanvas.addEventListener('mouseup', (e) => {
  if (draggingNode) {
    const node = nodes.find(n => n.id === draggingNode);
    if (node) node.pinned = false;
    draggingNode = null;
    dirty = true;
  }
  panning = false;
  mainCanvas.classList.remove('grabbing');
});

mainCanvas.addEventListener('dblclick', (e) => {
  const node = hitTest(e.clientX, e.clientY);
  if (node) {
    selectedNode = node.id;
    startEdit(node.id);
  } else {
    const w = screenToWorld(e.clientX, e.clientY);
    const id = createNode('New node', w.x, w.y, null, false);
    selectedNode = id;
    startEdit(id);
  }
});

mainCanvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const node = hitTest(e.clientX, e.clientY);
  if (node) {
    contextNodeId = node.id;
    selectedNode = node.id;
    const menu = document.getElementById('contextMenu');
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.classList.add('show');
  }
});

// Scroll zoom
mainCanvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const oldZoom = zoom;
  const delta = e.deltaY > 0 ? 0.93 : 1.07;
  zoom = Math.max(0.1, Math.min(5, zoom * delta));
  pan.x = e.clientX - (e.clientX - pan.x) * (zoom / oldZoom);
  pan.y = e.clientY - (e.clientY - pan.y) * (zoom / oldZoom);
}, { passive: false });

// Touch support
let touchStartDist = null;
let touchStartZoom = null;

mainCanvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    const t = e.touches[0];
    const node = hitTest(t.clientX, t.clientY);
    if (node) {
      selectedNode = node.id;
      draggingNode = node.id;
      node.pinned = true;
      const p = worldToScreen(node.x, node.y);
      dragOffset = { x: t.clientX - p.x, y: t.clientY - p.y };
    } else {
      panning = true;
      panStart = { x: t.clientX - pan.x, y: t.clientY - pan.y };
    }
  } else if (e.touches.length === 2) {
    panning = false;
    draggingNode = null;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchStartDist = Math.sqrt(dx * dx + dy * dy);
    touchStartZoom = zoom;
  }
}, { passive: true });

mainCanvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 1) {
    const t = e.touches[0];
    if (draggingNode) {
      const node = nodes.find(n => n.id === draggingNode);
      if (node) {
        const wx = (t.clientX - dragOffset.x - pan.x) / zoom;
        const wy = (t.clientY - dragOffset.y - pan.y) / zoom;
        node.vx = (wx - node.x) * 0.3;
        node.vy = (wy - node.y) * 0.3;
        node.x = wx;
        node.y = wy;
        dirty = true;
      }
    } else if (panning) {
      pan.x = t.clientX - panStart.x;
      pan.y = t.clientY - panStart.y;
    }
  } else if (e.touches.length === 2 && touchStartDist) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const oldZoom = zoom;
    zoom = Math.max(0.1, Math.min(5, touchStartZoom * (dist / touchStartDist)));
    pan.x = cx - (cx - pan.x) * (zoom / oldZoom);
    pan.y = cy - (cy - pan.y) * (zoom / oldZoom);
  }
}, { passive: false });

mainCanvas.addEventListener('touchend', (e) => {
  if (draggingNode) {
    const node = nodes.find(n => n.id === draggingNode);
    if (node) node.pinned = false;
    draggingNode = null;
    dirty = true;
  }
  panning = false;
  touchStartDist = null;
});

// Keyboard
document.addEventListener('keydown', (e) => {
  if (editingNode) {
    if (e.key === 'Escape') stopEdit(false);
    if (e.key === 'Enter') stopEdit(true);
    if (e.key === 'Tab') {
      e.preventDefault();
      stopEdit(true);
      if (selectedNode) addChild(selectedNode);
    }
    return;
  }

  if (e.key === 'Tab' && selectedNode) {
    e.preventDefault();
    addChild(selectedNode);
  }
  if (e.key === 'Delete' && selectedNode) {
    deleteNode(selectedNode);
  }
  if (e.key === 'F2' && selectedNode) {
    startEdit(selectedNode);
  }
  if (e.key === 'Escape') {
    selectedNode = null;
    hideContext();
  }
});

// ── Edit overlay ──
function startEdit(id) {
  const node = nodes.find(n => n.id === id);
  if (!node) return;
  editingNode = id;
  const overlay = document.getElementById('editOverlay');
  const input = document.getElementById('editInput');
  const p = worldToScreen(node.x, node.y);
  const r = getNodeRadius(node);

  overlay.style.left = (p.x - 80) + 'px';
  overlay.style.top = (p.y + r + 8) + 'px';
  overlay.classList.add('show');
  input.value = node.label;
  input.focus();
  input.select();
}

function stopEdit(save) {
  if (!editingNode) return;
  const node = nodes.find(n => n.id === editingNode);
  if (node && save) {
    const input = document.getElementById('editInput');
    node.label = input.value || 'Untitled';
    dirty = true;
  }
  editingNode = null;
  document.getElementById('editOverlay').classList.remove('show');
}

document.getElementById('editInput').addEventListener('blur', () => stopEdit(true));

// ── Context menu ──
function hideContext() {
  document.getElementById('contextMenu').classList.remove('show');
  contextNodeId = null;
}

function ctxAction(action) {
  if (!contextNodeId) return;
  switch (action) {
    case 'rename': startEdit(contextNodeId); break;
    case 'addChild': addChild(contextNodeId); break;
    case 'delete': deleteNode(contextNodeId); break;
  }
  hideContext();
}

document.addEventListener('click', (e) => {
  if (!document.getElementById('contextMenu').contains(e.target)) hideContext();
});

// Color dots
(function setupColors() {
  const container = document.getElementById('colorDots');
  NODE_COLORS.forEach(color => {
    const dot = document.createElement('div');
    dot.className = 'color-dot';
    dot.style.background = color;
    dot.onclick = () => {
      if (contextNodeId) {
        const node = nodes.find(n => n.id === contextNodeId);
        if (node) { node.color = color; dirty = true; }
      }
      hideContext();
    };
    container.appendChild(dot);
  });
})();

// ── Toolbar actions ──
function togglePhysics() {
  physicsEnabled = !physicsEnabled;
  document.getElementById('physToggle').textContent = physicsEnabled ? 'ON' : 'OFF';
}

function fitView() {
  if (nodes.length === 0) return;
  const pad = 120;
  const xs = nodes.map(n => n.x);
  const ys = nodes.map(n => n.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const w = maxX - minX || 400;
  const h = maxY - minY || 400;
  zoom = Math.min((window.innerWidth - pad * 2) / w, (window.innerHeight - pad * 2) / h, 2);
  pan.x = window.innerWidth / 2 - ((minX + maxX) / 2) * zoom;
  pan.y = window.innerHeight / 2 - ((minY + maxY) / 2) * zoom;
}

// ── Save / Load ──
function getStateData() {
  return { nodes: nodes.map(n => ({ id: n.id, label: n.label, x: n.x, y: n.y, isRoot: n.isRoot, color: n.color })), edges, nextId };
}

function loadStateData(data) {
  nodes = (data.nodes || []).map(n => ({ ...n, vx: 0, vy: 0, pinned: false }));
  edges = data.edges || [];
  nextId = data.nextId || nodes.length + 1;
  selectedNode = null;
  editingNode = null;
}

function exportJSON() {
  const data = JSON.stringify(getStateData(), null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'nodeflow-map.json'; a.click();
  URL.revokeObjectURL(url);
  showToast('Map saved to file');
}

function handleFileLoad(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      loadStateData(data);
      fitView();
      dirty = true;
      showToast('Map loaded');
    } catch { showToast('Invalid file'); }
  };
  reader.readAsText(file);
  e.target.value = '';
}

function clearAll() {
  if (!confirm('Clear everything?')) return;
  nodes = []; edges = []; nextId = 1;
  selectedNode = null;
  pan = { x: 0, y: 0 }; zoom = 1;
  const cx = (window.innerWidth / 2 - pan.x) / zoom;
  const cy = (window.innerHeight / 2 - pan.y) / zoom;
  createNode('Central Idea', cx, cy, null, true);
  dirty = true;
  showToast('Cleared');
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

// ══════════════════════════════════════
// ── Cloud Sync (Supabase) ──
// ══════════════════════════════════════
let supabaseClient = null;
let cloudReady = false;
let saveTimeout = null;

async function initSupabase() {
  try {
    supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    cloudReady = true;
    updateSync('saved');
  } catch (e) {
    console.error('Supabase init failed:', e);
    updateSync('error');
  }
}

async function cloudSave() {
  if (!cloudReady || !supabaseClient) return;
  try {
    const { error } = await supabaseClient
      .from('maps')
      .upsert({ id: MAP_ID, data: getStateData(), updated_at: new Date().toISOString() }, { onConflict: 'id' });
    if (error) throw error;
    updateSync('saved');
  } catch (e) {
    console.error('Cloud save failed:', e);
    updateSync('error');
  }
}

async function cloudLoad() {
  if (!cloudReady || !supabaseClient) return null;
  try {
    const { data, error } = await supabaseClient
      .from('maps')
      .select('data')
      .eq('id', MAP_ID)
      .single();
    if (error && error.code !== 'PGRST116') throw error;
    return data?.data || null;
  } catch (e) {
    console.error('Cloud load failed:', e);
    return null;
  }
}

function localSave() {
  try { localStorage.setItem('nodeflow-save', JSON.stringify(getStateData())); } catch {}
}

function localLoad() {
  try { const r = localStorage.getItem('nodeflow-save'); return r ? JSON.parse(r) : null; } catch { return null; }
}

function debouncedCloudSave() {
  localSave();
  updateSync('saving');
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => cloudSave(), 2000);
}

function updateSync(status) {
  const el = document.getElementById('syncStatus');
  switch (status) {
    case 'saving': el.textContent = '⟳ saving...'; el.style.color = '#666'; break;
    case 'saved': el.textContent = '☁ synced'; el.style.color = '#6fefb2'; break;
    case 'error': el.textContent = '⚠ offline'; el.style.color = '#ef6f8a'; break;
    case 'loading': el.textContent = '↓ loading...'; el.style.color = '#6fb8ef'; break;
  }
}

// Dirty check loop for saves
setInterval(() => {
  if (dirty) {
    dirty = false;
    debouncedCloudSave();
  }
}, 3000);

// ── Boot ──
async function boot() {
  resize();

  await initSupabase();
  updateSync('loading');

  const cloudData = await cloudLoad();
  if (cloudData && cloudData.nodes && cloudData.nodes.length > 0) {
    loadStateData(cloudData);
    fitView();
    showToast('Loaded from cloud');
  } else {
    const local = localLoad();
    if (local && local.nodes && local.nodes.length > 0) {
      loadStateData(local);
      fitView();
      dirty = true;
      showToast('Local map pushed to cloud');
    } else {
      const cx = (window.innerWidth / 2 - pan.x) / zoom;
      const cy = (window.innerHeight / 2 - pan.y) / zoom;
      createNode('Central Idea', cx, cy, null, true);
    }
  }

  updateSync('saved');
  loop();
}

boot();
</script>
</body>
</html>
