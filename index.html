<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NodeFlow</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1b1e;
    overflow: hidden;
    font-family: 'DM Sans', sans-serif;
    color: #c4c4c8;
    user-select: none;
    height: 100vh;
    width: 100vw;
  }

  #canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0; left: 0;
    cursor: grab;
  }

  #canvas.grabbing { cursor: grabbing; }

  svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  svg line {
    stroke: #3a3b40;
    stroke-width: 1.5;
    opacity: 0.7;
    transition: opacity 0.3s;
  }

  svg line.highlight {
    stroke: #7c6fef;
    opacity: 1;
    stroke-width: 2;
  }

  .node {
    position: absolute;
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 6px;
    transform: translate(-50%, -50%);
    cursor: pointer;
    transition: filter 0.2s;
  }

  .node:hover { filter: brightness(1.2); }

  .node-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #5e5a72;
    border: 2px solid #7c6fef;
    flex-shrink: 0;
    transition: all 0.2s;
    box-shadow: 0 0 0 0 rgba(124, 111, 239, 0);
  }

  .node:hover .node-dot,
  .node.selected .node-dot {
    background: #7c6fef;
    box-shadow: 0 0 12px 2px rgba(124, 111, 239, 0.4);
  }

  .node.root .node-dot {
    width: 18px;
    height: 18px;
    background: #7c6fef;
    border-color: #9d93f5;
  }

  .node-label {
    font-size: 13px;
    font-weight: 500;
    color: #d1d1d6;
    white-space: nowrap;
    letter-spacing: 0.01em;
    pointer-events: none;
    text-shadow: 0 1px 4px rgba(0,0,0,0.6);
  }

  .node.root .node-label {
    font-size: 15px;
    font-weight: 600;
    color: #eee;
  }

  .node-input {
    background: transparent;
    border: none;
    outline: none;
    color: #eee;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    font-weight: 500;
    width: 140px;
    caret-color: #7c6fef;
    letter-spacing: 0.01em;
  }

  .node.root .node-input {
    font-size: 15px;
    font-weight: 600;
  }

  /* Add child ring */
  .add-ring {
    position: absolute;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: #2a2b30;
    border: 1.5px solid #4a4b52;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #7c6fef;
    cursor: pointer;
    opacity: 0;
    transition: all 0.2s;
    z-index: 20;
    pointer-events: none;
    transform: translate(-50%, -50%);
    font-weight: 600;
  }

  .node:hover .add-ring,
  .node.selected .add-ring {
    opacity: 1;
    pointer-events: auto;
  }

  .add-ring:hover {
    background: #7c6fef;
    color: #fff;
    border-color: #7c6fef;
    transform: translate(-50%, -50%) scale(1.15);
  }

  /* Delete button */
  .delete-btn {
    position: absolute;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #2a2b30;
    border: 1.5px solid #4a4b52;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    color: #e55;
    cursor: pointer;
    opacity: 0;
    transition: all 0.2s;
    z-index: 20;
    pointer-events: none;
    transform: translate(-50%, -50%);
  }

  .node:hover .delete-btn {
    opacity: 0.7;
    pointer-events: auto;
  }

  .delete-btn:hover {
    opacity: 1;
    background: #e55;
    color: #fff;
    border-color: #e55;
  }

  .node.root .delete-btn { display: none; }

  /* Toolbar */
  .toolbar {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    background: #242529;
    border: 1px solid #3a3b40;
    border-radius: 12px;
    padding: 8px 12px;
    z-index: 100;
    align-items: center;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  }

  .toolbar button {
    background: transparent;
    border: 1px solid transparent;
    color: #999;
    padding: 6px 12px;
    border-radius: 8px;
    font-family: 'DM Sans', sans-serif;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    gap: 5px;
    white-space: nowrap;
  }

  .toolbar button:hover {
    background: #2f3035;
    color: #ddd;
    border-color: #4a4b52;
  }

  .toolbar .sep {
    width: 1px;
    height: 20px;
    background: #3a3b40;
    margin: 0 4px;
  }

  /* Title */
  .title-bar {
    position: fixed;
    top: 20px;
    left: 24px;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .title-bar .logo {
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    font-weight: 500;
    color: #7c6fef;
    letter-spacing: -0.5px;
  }

  .title-bar .dot {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: #4a4b52;
  }

  .title-bar .hint {
    font-size: 12px;
    color: #555;
    font-style: italic;
  }

  /* Zoom indicator */
  .zoom-indicator {
    position: fixed;
    top: 20px;
    right: 24px;
    z-index: 100;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: #555;
  }

  .sync-status {
    position: fixed;
    top: 38px;
    right: 24px;
    z-index: 100;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: #666;
    transition: color 0.3s;
  }

  /* Minimap */
  .minimap {
    position: fixed;
    bottom: 80px;
    right: 20px;
    width: 160px;
    height: 110px;
    background: #222327;
    border: 1px solid #3a3b40;
    border-radius: 8px;
    z-index: 100;
    overflow: hidden;
    opacity: 0.7;
    transition: opacity 0.2s;
  }

  .minimap:hover { opacity: 1; }

  .minimap canvas {
    width: 100%;
    height: 100%;
  }

  /* Context menu */
  .context-menu {
    position: fixed;
    background: #242529;
    border: 1px solid #3a3b40;
    border-radius: 10px;
    padding: 4px;
    z-index: 200;
    min-width: 160px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    display: none;
  }

  .context-menu.show { display: block; }

  .context-menu button {
    display: block;
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    color: #c4c4c8;
    font-family: 'DM Sans', sans-serif;
    font-size: 12px;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.1s;
  }

  .context-menu button:hover {
    background: #2f3035;
    color: #eee;
  }

  .context-menu button.danger { color: #e55; }
  .context-menu button.danger:hover { background: rgba(238,85,85,0.1); }

  /* Toast */
  .toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-60px);
    background: #242529;
    border: 1px solid #3a3b40;
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 12px;
    color: #aaa;
    z-index: 300;
    transition: transform 0.3s ease;
    pointer-events: none;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  }

  .toast.show { transform: translateX(-50%) translateY(0); }

  /* Color picker */
  .color-dots {
    display: flex;
    gap: 4px;
    padding: 4px 8px;
  }

  .color-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.15s;
  }

  .color-dot:hover { transform: scale(1.2); border-color: #fff3; }
</style>
</head>
<body>

<div class="title-bar">
  <span class="logo">NodeFlow</span>
  <span class="dot"></span>
  <span class="hint">click a node's + to branch · double-click to rename · drag to move</span>
</div>

<div class="zoom-indicator" id="zoomIndicator">100%</div>
<div class="sync-status" id="syncStatus">connecting...</div>

<div id="canvas">
  <svg id="edgeSvg"></svg>
  <div id="nodeContainer"></div>
</div>

<div class="toolbar">
  <button onclick="fitView()" title="Fit all nodes in view">⊡ Fit View</button>
  <div class="sep"></div>
  <button onclick="addFloatingNode()" title="Add unconnected node">+ Free Node</button>
  <div class="sep"></div>
  <button onclick="exportJSON()" title="Save to file">↓ Save</button>
  <button onclick="importJSON()" title="Load from file">↑ Load</button>
  <div class="sep"></div>
  <button onclick="clearAll()" title="Clear everything">✕ Clear</button>
</div>

<div class="minimap" id="minimap">
  <canvas id="minimapCanvas"></canvas>
</div>

<div class="context-menu" id="contextMenu">
  <button onclick="contextAction('rename')">✎ Rename</button>
  <button onclick="contextAction('addChild')">+ Add Child</button>
  <div class="color-dots" id="colorDots"></div>
  <button class="danger" onclick="contextAction('delete')">✕ Delete</button>
</div>

<div class="toast" id="toast"></div>

<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileLoad(event)">

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
// ── State ──
let nodes = [];
let edges = [];
let nextId = 1;
let pan = { x: 0, y: 0 };
let zoom = 1;
let dragging = null;
let panning = false;
let panStart = { x: 0, y: 0 };
let selectedNode = null;
let contextNodeId = null;

const NODE_COLORS = [
  '#7c6fef', '#ef6f8a', '#6fefb2', '#efcf6f', '#6fb8ef', '#ef8f6f', '#b86fef', '#6fefd4'
];

const canvas = document.getElementById('canvas');
const svg = document.getElementById('edgeSvg');
const nodeContainer = document.getElementById('nodeContainer');
const contextMenu = document.getElementById('contextMenu');

// ── Init ──
function init() {
  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2;
  createNode('Central Idea', cx, cy, null, true);
  renderAll();
  setupColorDots();
}

function setupColorDots() {
  const container = document.getElementById('colorDots');
  NODE_COLORS.forEach(color => {
    const dot = document.createElement('div');
    dot.className = 'color-dot';
    dot.style.background = color;
    dot.onclick = () => {
      if (contextNodeId != null) {
        const node = nodes.find(n => n.id === contextNodeId);
        if (node) { node.color = color; renderAll(); }
      }
      hideContext();
    };
    container.appendChild(dot);
  });
}

// ── Node CRUD ──
function createNode(label, x, y, parentId, isRoot) {
  const id = nextId++;
  const color = isRoot ? '#7c6fef' : (parentId != null ? (nodes.find(n => n.id === parentId)?.color || '#7c6fef') : '#5e5a72');
  const node = { id, label, x: (x - pan.x) / zoom, y: (y - pan.y) / zoom, isRoot: !!isRoot, color };
  nodes.push(node);
  if (parentId != null) {
    edges.push({ from: parentId, to: id });
  }
  renderAll();
  // Auto focus for rename
  setTimeout(() => {
    if (!isRoot) startRename(id);
  }, 50);
  return id;
}

function deleteNode(id) {
  const node = nodes.find(n => n.id === id);
  if (!node || node.isRoot) return;
  // Collect all descendants
  const toDelete = new Set();
  const queue = [id];
  while (queue.length) {
    const curr = queue.shift();
    toDelete.add(curr);
    edges.filter(e => e.from === curr).forEach(e => queue.push(e.to));
  }
  nodes = nodes.filter(n => !toDelete.has(n.id));
  edges = edges.filter(e => !toDelete.has(e.from) && !toDelete.has(e.to));
  renderAll();
}

function addChild(parentId) {
  const parent = nodes.find(n => n.id === parentId);
  if (!parent) return;
  // Find angle with least neighbors
  const siblings = edges.filter(e => e.from === parentId).map(e => nodes.find(n => n.id === e.to)).filter(Boolean);
  const parentEdge = edges.find(e => e.to === parentId);
  const parentNode = parentEdge ? nodes.find(n => n.id === parentEdge.from) : null;

  let angle;
  const dist = 150;

  if (siblings.length === 0 && !parentNode) {
    angle = -Math.PI / 4;
  } else {
    // Collect existing angles
    const angles = [];
    siblings.forEach(s => angles.push(Math.atan2(s.y - parent.y, s.x - parent.x)));
    if (parentNode) angles.push(Math.atan2(parentNode.y - parent.y, parentNode.x - parent.x));

    // Find biggest gap
    angles.sort((a, b) => a - b);
    let maxGap = 0, bestAngle = 0;

    if (angles.length === 1) {
      bestAngle = angles[0] + Math.PI;
    } else {
      for (let i = 0; i < angles.length; i++) {
        const next = i + 1 < angles.length ? angles[i + 1] : angles[0] + 2 * Math.PI;
        const gap = next - angles[i];
        if (gap > maxGap) { maxGap = gap; bestAngle = angles[i] + gap / 2; }
      }
    }
    angle = bestAngle;
  }

  const nx = parent.x + Math.cos(angle) * dist;
  const ny = parent.y + Math.sin(angle) * dist;
  const screenX = nx * zoom + pan.x;
  const screenY = ny * zoom + pan.y;
  createNode('New node', screenX, screenY, parentId);
}

function addFloatingNode() {
  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2;
  createNode('New node', cx, cy, null, false);
}

// ── Render ──
function renderAll() {
  renderEdges();
  renderNodes();
  renderMinimap();
  document.getElementById('zoomIndicator').textContent = Math.round(zoom * 100) + '%';
}

function renderEdges() {
  svg.innerHTML = '';
  edges.forEach(edge => {
    const from = nodes.find(n => n.id === edge.from);
    const to = nodes.find(n => n.id === edge.to);
    if (!from || !to) return;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', from.x * zoom + pan.x);
    line.setAttribute('y1', from.y * zoom + pan.y);
    line.setAttribute('x2', to.x * zoom + pan.x);
    line.setAttribute('y2', to.y * zoom + pan.y);
    if (selectedNode && (edge.from === selectedNode || edge.to === selectedNode)) {
      line.classList.add('highlight');
    }
    svg.appendChild(line);
  });
}

function renderNodes() {
  // Keep track of existing editing states
  const editingId = nodeContainer.querySelector('.node-input')?.closest('.node')?.dataset?.id;

  nodeContainer.innerHTML = '';
  nodes.forEach(node => {
    const el = document.createElement('div');
    el.className = 'node' + (node.isRoot ? ' root' : '') + (selectedNode === node.id ? ' selected' : '');
    el.dataset.id = node.id;

    const sx = node.x * zoom + pan.x;
    const sy = node.y * zoom + pan.y;
    el.style.left = sx + 'px';
    el.style.top = sy + 'px';

    // Dot
    const dot = document.createElement('div');
    dot.className = 'node-dot';
    dot.style.borderColor = node.color || '#7c6fef';
    if (node.isRoot || selectedNode === node.id) {
      dot.style.background = node.color || '#7c6fef';
    }

    // Label or input
    if (editingId == node.id) {
      const input = document.createElement('input');
      input.className = 'node-input';
      input.value = node.label;
      input.onblur = () => { node.label = input.value || 'Untitled'; renderAll(); };
      input.onkeydown = (e) => {
        if (e.key === 'Enter') { input.blur(); }
        if (e.key === 'Escape') { input.blur(); }
        if (e.key === 'Tab') {
          e.preventDefault();
          input.blur();
          addChild(node.id);
        }
      };
      el.appendChild(dot);
      el.appendChild(input);
      setTimeout(() => { input.focus(); input.select(); }, 10);
    } else {
      const label = document.createElement('span');
      label.className = 'node-label';
      label.textContent = node.label;
      el.appendChild(dot);
      el.appendChild(label);
    }

    // Add child button
    const addBtn = document.createElement('div');
    addBtn.className = 'add-ring';
    addBtn.textContent = '+';
    addBtn.style.left = '0px';
    addBtn.style.top = '-20px';
    addBtn.onclick = (e) => { e.stopPropagation(); addChild(node.id); };
    el.appendChild(addBtn);

    // Delete button
    if (!node.isRoot) {
      const delBtn = document.createElement('div');
      delBtn.className = 'delete-btn';
      delBtn.textContent = '✕';
      delBtn.style.right = '-8px';
      delBtn.style.top = '-8px';
      delBtn.style.left = 'auto';
      delBtn.style.position = 'absolute';
      delBtn.style.transform = 'none';
      delBtn.onclick = (e) => { e.stopPropagation(); deleteNode(node.id); };
      el.appendChild(delBtn);
    }

    // Events
    el.onmousedown = (e) => handleNodeMouseDown(e, node.id);
    el.ondblclick = (e) => { e.stopPropagation(); startRename(node.id); };
    el.oncontextmenu = (e) => { e.preventDefault(); showContext(e, node.id); };

    nodeContainer.appendChild(el);
  });
}

function startRename(id) {
  selectedNode = id;
  // Trigger re-render with edit mode
  const el = nodeContainer.querySelector(`[data-id="${id}"]`);
  if (!el) { renderAll(); return; }

  const node = nodes.find(n => n.id === id);
  const label = el.querySelector('.node-label');
  if (!label) return;

  const input = document.createElement('input');
  input.className = 'node-input';
  if (node.isRoot) input.classList.add('root');
  input.value = node.label;
  input.onblur = () => { node.label = input.value || 'Untitled'; renderAll(); };
  input.onkeydown = (e) => {
    if (e.key === 'Enter') input.blur();
    if (e.key === 'Escape') input.blur();
    if (e.key === 'Tab') {
      e.preventDefault();
      input.blur();
      addChild(node.id);
    }
  };
  label.replaceWith(input);
  input.focus();
  input.select();
}

// ── Interaction ──
function handleNodeMouseDown(e, id) {
  if (e.target.classList.contains('add-ring') || e.target.classList.contains('delete-btn')) return;
  if (e.button === 2) return;
  e.stopPropagation();
  selectedNode = id;
  const node = nodes.find(n => n.id === id);
  dragging = {
    id,
    offsetX: e.clientX - (node.x * zoom + pan.x),
    offsetY: e.clientY - (node.y * zoom + pan.y)
  };
  renderAll();
}

// Pan
canvas.onmousedown = (e) => {
  if (e.target === canvas || e.target === svg || e.target === nodeContainer) {
    hideContext();
    selectedNode = null;
    panning = true;
    panStart = { x: e.clientX - pan.x, y: e.clientY - pan.y };
    canvas.classList.add('grabbing');
    renderAll();
  }
};

window.onmousemove = (e) => {
  if (dragging) {
    const node = nodes.find(n => n.id === dragging.id);
    if (node) {
      node.x = (e.clientX - dragging.offsetX - pan.x) / zoom;
      node.y = (e.clientY - dragging.offsetY - pan.y) / zoom;
      renderAll();
    }
  } else if (panning) {
    pan.x = e.clientX - panStart.x;
    pan.y = e.clientY - panStart.y;
    renderAll();
  }
};

window.onmouseup = () => {
  dragging = null;
  panning = false;
  canvas.classList.remove('grabbing');
};

// Zoom
canvas.onwheel = (e) => {
  e.preventDefault();
  const oldZoom = zoom;
  const delta = e.deltaY > 0 ? 0.92 : 1.08;
  zoom = Math.max(0.15, Math.min(4, zoom * delta));

  // Zoom toward cursor
  pan.x = e.clientX - (e.clientX - pan.x) * (zoom / oldZoom);
  pan.y = e.clientY - (e.clientY - pan.y) * (zoom / oldZoom);

  renderAll();
};

// Double click on canvas to add root-level node
canvas.ondblclick = (e) => {
  if (e.target === canvas || e.target === svg || e.target === nodeContainer) {
    createNode('New node', e.clientX, e.clientY, null, false);
  }
};

// ── Context Menu ──
function showContext(e, id) {
  contextNodeId = id;
  contextMenu.style.left = e.clientX + 'px';
  contextMenu.style.top = e.clientY + 'px';
  contextMenu.classList.add('show');
}

function hideContext() {
  contextMenu.classList.remove('show');
  contextNodeId = null;
}

function contextAction(action) {
  if (contextNodeId == null) return;
  switch (action) {
    case 'rename': startRename(contextNodeId); break;
    case 'addChild': addChild(contextNodeId); break;
    case 'delete': deleteNode(contextNodeId); break;
  }
  hideContext();
}

document.addEventListener('click', (e) => {
  if (!contextMenu.contains(e.target)) hideContext();
});

// ── Keyboard ──
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;

  if (e.key === 'Tab' && selectedNode) {
    e.preventDefault();
    addChild(selectedNode);
  }
  if (e.key === 'Delete' && selectedNode) {
    deleteNode(selectedNode);
    selectedNode = null;
    renderAll();
  }
  if (e.key === 'F2' && selectedNode) {
    startRename(selectedNode);
  }
  if (e.key === 'Escape') {
    selectedNode = null;
    hideContext();
    renderAll();
  }
});

// ── Fit View ──
function fitView() {
  if (nodes.length === 0) return;
  const pad = 100;
  const xs = nodes.map(n => n.x);
  const ys = nodes.map(n => n.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const w = maxX - minX || 400;
  const h = maxY - minY || 400;
  const scaleX = (window.innerWidth - pad * 2) / w;
  const scaleY = (window.innerHeight - pad * 2) / h;
  zoom = Math.min(scaleX, scaleY, 2);
  pan.x = window.innerWidth / 2 - ((minX + maxX) / 2) * zoom;
  pan.y = window.innerHeight / 2 - ((minY + maxY) / 2) * zoom;
  renderAll();
}

// ── Minimap ──
function renderMinimap() {
  const mc = document.getElementById('minimapCanvas');
  const ctx = mc.getContext('2d');
  mc.width = 160;
  mc.height = 110;
  ctx.clearRect(0, 0, 160, 110);

  if (nodes.length === 0) return;

  const xs = nodes.map(n => n.x);
  const ys = nodes.map(n => n.y);
  const minX = Math.min(...xs) - 100, maxX = Math.max(...xs) + 100;
  const minY = Math.min(...ys) - 100, maxY = Math.max(...ys) + 100;
  const w = maxX - minX || 1;
  const h = maxY - minY || 1;
  const scale = Math.min(150 / w, 100 / h);
  const ox = (160 - w * scale) / 2 - minX * scale;
  const oy = (110 - h * scale) / 2 - minY * scale;

  // Edges
  ctx.strokeStyle = '#3a3b40';
  ctx.lineWidth = 1;
  edges.forEach(e => {
    const from = nodes.find(n => n.id === e.from);
    const to = nodes.find(n => n.id === e.to);
    if (!from || !to) return;
    ctx.beginPath();
    ctx.moveTo(from.x * scale + ox, from.y * scale + oy);
    ctx.lineTo(to.x * scale + ox, to.y * scale + oy);
    ctx.stroke();
  });

  // Nodes
  nodes.forEach(n => {
    ctx.fillStyle = n.color || '#7c6fef';
    ctx.beginPath();
    ctx.arc(n.x * scale + ox, n.y * scale + oy, n.isRoot ? 3 : 2, 0, Math.PI * 2);
    ctx.fill();
  });

  // Viewport rectangle
  const vl = (-pan.x / zoom);
  const vt = (-pan.y / zoom);
  const vr = (window.innerWidth - pan.x) / zoom;
  const vb = (window.innerHeight - pan.y) / zoom;
  ctx.strokeStyle = '#7c6fef44';
  ctx.lineWidth = 1;
  ctx.strokeRect(vl * scale + ox, vt * scale + oy, (vr - vl) * scale, (vb - vt) * scale);
}

// ── Save / Load ──
function exportJSON() {
  const data = JSON.stringify({ nodes, edges, nextId, pan, zoom }, null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'nodeflow-map.json';
  a.click();
  URL.revokeObjectURL(url);
  showToast('Map saved');
}

function importJSON() {
  document.getElementById('fileInput').click();
}

function handleFileLoad(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      nodes = data.nodes || [];
      edges = data.edges || [];
      nextId = data.nextId || nodes.length + 1;
      pan = data.pan || { x: 0, y: 0 };
      zoom = data.zoom || 1;
      selectedNode = null;
      renderAll();
      showToast('Map loaded');
    } catch { showToast('Invalid file'); }
  };
  reader.readAsText(file);
  e.target.value = '';
}

function clearAll() {
  if (!confirm('Clear everything?')) return;
  nodes = [];
  edges = [];
  nextId = 1;
  selectedNode = null;
  pan = { x: 0, y: 0 };
  zoom = 1;
  init();
  showToast('Cleared');
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

// ══════════════════════════════════════════
// ── SETUP: Replace these with your values ──
const SUPABASE_URL = 'qsphmbquuruguemgdiym';
const SUPABASE_KEY = 'sb_publishable_-uS8PtHTOvoVc5-MZrkvrA_Wbt5ljBz';
const MAP_ID = 'default';
// ══════════════════════════════════════════

let saveTimeout = null;
let cloudReady = false;
let supabaseClient = null;

async function initSupabase() {
  try {
    const { createClient } = supabase;
    supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);
    cloudReady = true;
    showToast('☁ Connected');
  } catch(e) {
    console.error('Supabase init failed:', e);
    showToast('⚠ Offline mode');
  }
}

// ── Auto-save (debounced) ──
const STORAGE_KEY = 'nodeflow-save';

function localSave() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ nodes, edges, nextId, pan, zoom }));
  } catch(e) {}
}

function localLoad() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) return JSON.parse(raw);
  } catch(e) {}
  return null;
}

async function cloudSave() {
  if (!cloudReady || !supabaseClient) return;
  try {
    const payload = { nodes, edges, nextId, pan, zoom };
    const { error } = await supabaseClient
      .from('maps')
      .upsert({ id: MAP_ID, data: payload, updated_at: new Date().toISOString() }, { onConflict: 'id' });
    if (error) throw error;
    updateSyncStatus('saved');
  } catch(e) {
    console.error('Cloud save failed:', e);
    updateSyncStatus('error');
  }
}

async function cloudLoad() {
  if (!cloudReady || !supabaseClient) return null;
  try {
    const { data, error } = await supabaseClient
      .from('maps')
      .select('data')
      .eq('id', MAP_ID)
      .single();
    if (error && error.code !== 'PGRST116') throw error;
    return data?.data || null;
  } catch(e) {
    console.error('Cloud load failed:', e);
    return null;
  }
}

function debouncedSave() {
  localSave();
  updateSyncStatus('saving');
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => cloudSave(), 1500);
}

function updateSyncStatus(status) {
  const el = document.getElementById('syncStatus');
  if (!el) return;
  switch(status) {
    case 'saving': el.textContent = '⟳ saving...'; el.style.color = '#666'; break;
    case 'saved': el.textContent = '☁ synced'; el.style.color = '#6fefb2'; break;
    case 'error': el.textContent = '⚠ offline'; el.style.color = '#ef6f8a'; break;
    case 'loading': el.textContent = '↓ loading...'; el.style.color = '#6fb8ef'; break;
  }
}

// Hook auto-save into every change
const _origRenderAll = renderAll;
renderAll = function() {
  _origRenderAll();
  debouncedSave();
};

// ── Start ──
async function boot() {
  await initSupabase();

  updateSyncStatus('loading');
  const cloudData = await cloudLoad();

  if (cloudData && cloudData.nodes && cloudData.nodes.length > 0) {
    nodes = cloudData.nodes;
    edges = cloudData.edges || [];
    nextId = cloudData.nextId || nodes.length + 1;
    pan = cloudData.pan || { x: 0, y: 0 };
    zoom = cloudData.zoom || 1;
    selectedNode = null;
    _origRenderAll();
    updateSyncStatus('saved');
    showToast('Map loaded from cloud');
  } else {
    const local = localLoad();
    if (local && local.nodes && local.nodes.length > 0) {
      nodes = local.nodes;
      edges = local.edges || [];
      nextId = local.nextId || nodes.length + 1;
      pan = local.pan || { x: 0, y: 0 };
      zoom = local.zoom || 1;
      selectedNode = null;
      _origRenderAll();
      cloudSave(); // push local to cloud
      showToast('Local map pushed to cloud');
    } else {
      init();
    }
  }
}

boot();
</script>
</body>
</html>
